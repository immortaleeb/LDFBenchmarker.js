#!/usr/bin/env node

/* Simple benchmarking application for testing different TPF clients */

var fs = require('fs'),
  LineByLineReader = require('line-by-line'),
  spawn = require('child_process').spawn,
  trackPID = require('./lib/monitor_mod');

var args = process.argv.slice(2);
if (args.length < 2 || args.length > 4 || /^--?h(elp)?$/.test(args[0])) {
  console.log('usage: ./run-tests.js queryFile startFragment [timeout [optimized]]');
  return process.exit(1);
}

var file = args[0],
  startFragment = args[1],
  timeOut = args[2] || 60000, // default 60s
  optimized = (args[3] && args[3] === 'optimized'),
  node = process.argv[0],
  clientPath = './clients/ldf-client/bin/ldf-client',
  ioSettings = { stdio: ['pipe', 'pipe', 'pipe'] },
  parameters = ['-t', 'debug', '-l', 'INFO'];

if (optimized)
  parameters.push('-a', '2');

var lr = new LineByLineReader(file);

var id = 0;


console.log("file,id,timeFirst(ms),timeHalf(ms),time(ms),resultCount,requestCount,timeOut,cpu(%),memory(MB)");

lr.on('error', function (err) {
  // 'err' contains error object
  console.error(err);
});

lr.on('line', function (query) {
  // 'line' contains the current line without the trailing newline character.
  lr.pause();

  id++;
  requestCount = 0;

  // Measurements
  var delays = [],
    totalDelay = timeOut,
    requestCount = 0,
    isTimeOut = false,
    cpu = 0,
    memory = 0,
    steps = 0;

  var start = process.hrtime();

  var client = spawn(node,[clientPath, startFragment, query].concat(parameters), ioSettings);
  var tracker = new trackPID(client.pid, 200, function (result) {
    cpu += result.cpu;
    memory += result.memory / 1000000;
    steps++;
  });

  client.stdout.setEncoding('utf8');
  client.stderr.setEncoding('utf8');
  // Log HTTP requests
  client.stderr.on('data', function (data) {
    if (data.indexOf('INFO HttpClient') > -1)
      requestCount++;
    process.stderr.write(data);
  });

  var to = setTimeout(function () {
    isTimeOut = true;
    client.kill();
  }, timeOut);

  client.stdout.on('data', function (result) {
    var parsed = result.split(',');
    if (parsed[0] === 'TOTAL')
      totalDelay = parseFloat(parsed[1]);
    else
      delays.push(parseFloat(parsed[1]));
  });

  client.on('exit', function (code, signal) {
    tracker.stop();
    clearTimeout(to);
    client.removeAllListeners();
    if (code !== null) {
      console.log('%s,%d,%d,%d,%d,%d,%d,%s,%d,%d',
      file,
      id,
      delays.length > 0 ? delays[0] : -1,
      delays.length > 0 ? delays[Math.ceil((delays.length - 1) / 2)] : -1,
      totalDelay,
      delays.length,
      requestCount,
      isTimeOut,
      cpu / steps,
      memory / steps);

      lr.resume();
    } else
      console.error('ERROR: client exited abnormally: %s', signal);
  });
});

lr.on('end', function () {
  // All lines are read, file is closed now.
  console.error('--- End of run ---');
  process.exit(0);
});
